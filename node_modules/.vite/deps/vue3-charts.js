import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  defineComponent,
  inject,
  mergeProps,
  normalizeClass,
  normalizeStyle,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  toDisplayString,
  watch,
  withCtx
} from "./chunk-PBWN42R4.js";
import "./chunk-SSYGV25P.js";

// node_modules/vue3-charts/dist/vue3-charts.esm.js
function _isPlaceholder(a) {
  return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
}
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}
function _arity(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}
function _curryN(length, received, fn) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left2 = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left2 -= 1;
      }
      combinedIdx += 1;
    }
    return left2 <= 0 ? fn.apply(this, combined) : _arity(left2, _curryN(length, combined, fn));
  };
}
var curryN = _curry2(function curryN2(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});
function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        });
      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function(_c) {
          return fn(a, b, _c);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function(_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function(_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}
var _isArray = Array.isArray || function _isArray2(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
};
function _isTransformer(obj) {
  return obj != null && typeof obj["@@transducer/step"] === "function";
}
function _dispatchable(methodNames, transducerCreator, fn) {
  return function() {
    if (arguments.length === 0) {
      return fn();
    }
    var obj = arguments[arguments.length - 1];
    if (!_isArray(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === "function") {
          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
}
var _xfBase = {
  init: function() {
    return this.xf["@@transducer/init"]();
  },
  result: function(result) {
    return this.xf["@@transducer/result"](result);
  }
};
function _map(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
}
function _isString(x2) {
  return Object.prototype.toString.call(x2) === "[object String]";
}
var _isArrayLike = _curry1(function isArrayLike(x2) {
  if (_isArray(x2)) {
    return true;
  }
  if (!x2) {
    return false;
  }
  if (typeof x2 !== "object") {
    return false;
  }
  if (_isString(x2)) {
    return false;
  }
  if (x2.length === 0) {
    return true;
  }
  if (x2.length > 0) {
    return x2.hasOwnProperty(0) && x2.hasOwnProperty(x2.length - 1);
  }
  return false;
});
var XWrap = function() {
  function XWrap2(fn) {
    this.f = fn;
  }
  XWrap2.prototype["@@transducer/init"] = function() {
    throw new Error("init not implemented on XWrap");
  };
  XWrap2.prototype["@@transducer/result"] = function(acc) {
    return acc;
  };
  XWrap2.prototype["@@transducer/step"] = function(acc, x2) {
    return this.f(acc, x2);
  };
  return XWrap2;
}();
function _xwrap(fn) {
  return new XWrap(fn);
}
var bind = _curry2(function bind2(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});
function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    acc = xf["@@transducer/step"](acc, list[idx]);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx += 1;
  }
  return xf["@@transducer/result"](acc);
}
function _iterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf["@@transducer/step"](acc, step.value);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    step = iter.next();
  }
  return xf["@@transducer/result"](acc);
}
function _methodReduce(xf, acc, obj, methodName) {
  return xf["@@transducer/result"](obj[methodName](bind(xf["@@transducer/step"], xf), acc));
}
var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
function _reduce(fn, acc, list) {
  if (typeof fn === "function") {
    fn = _xwrap(fn);
  }
  if (_isArrayLike(list)) {
    return _arrayReduce(fn, acc, list);
  }
  if (typeof list["fantasy-land/reduce"] === "function") {
    return _methodReduce(fn, acc, list, "fantasy-land/reduce");
  }
  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }
  if (typeof list.next === "function") {
    return _iterableReduce(fn, acc, list);
  }
  if (typeof list.reduce === "function") {
    return _methodReduce(fn, acc, list, "reduce");
  }
  throw new TypeError("reduce: list must be array or iterable");
}
var XMap = function() {
  function XMap2(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap2.prototype["@@transducer/init"] = _xfBase.init;
  XMap2.prototype["@@transducer/result"] = _xfBase.result;
  XMap2.prototype["@@transducer/step"] = function(result, input) {
    return this.xf["@@transducer/step"](result, this.f(input));
  };
  return XMap2;
}();
var _xmap = _curry2(function _xmap2(f, xf) {
  return new XMap(f, xf);
});
function _has(prop3, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop3);
}
var toString$1 = Object.prototype.toString;
var _isArguments = function() {
  return toString$1.call(arguments) === "[object Arguments]" ? function _isArguments2(x2) {
    return toString$1.call(x2) === "[object Arguments]";
  } : function _isArguments2(x2) {
    return _has("callee", x2);
  };
}();
var hasEnumBug = !{
  toString: null
}.propertyIsEnumerable("toString");
var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
var hasArgsEnumBug = function() {
  return arguments.propertyIsEnumerable("length");
}();
var contains = function contains2(list, item) {
  var idx = 0;
  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};
var keys2 = typeof Object.keys === "function" && !hasArgsEnumBug ? _curry1(function keys3(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : _curry1(function keys4(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop3, nIdx;
  var ks = [];
  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
  for (prop3 in obj) {
    if (_has(prop3, obj) && (!checkArgsLength || prop3 !== "length")) {
      ks[ks.length] = prop3;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop3 = nonEnumerableProps[nIdx];
      if (_has(prop3, obj) && !contains(ks, prop3)) {
        ks[ks.length] = prop3;
      }
      nIdx -= 1;
    }
  }
  return ks;
});
var map$1 = _curry2(
  _dispatchable(["fantasy-land/map", "map"], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case "[object Function]":
        return curryN(functor.length, function() {
          return fn.call(this, functor.apply(this, arguments));
        });
      case "[object Object]":
        return _reduce(function(acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys2(functor));
      default:
        return _map(fn, functor);
    }
  })
);
var map$2 = map$1;
var _isInteger = Number.isInteger || function _isInteger2(n) {
  return n << 0 === n;
};
var nth = _curry2(function nth2(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString(list) ? list.charAt(idx) : list[idx];
});
var nth$1 = nth;
var prop = _curry2(function prop2(p, obj) {
  if (obj == null) {
    return;
  }
  return _isInteger(p) ? nth$1(p, obj) : obj[p];
});
var prop$1 = prop;
var reduce = _curry3(_reduce);
var reduce$1 = reduce;
var values2 = _curry1(function values3(obj) {
  var props = keys2(obj);
  var len = props.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props[idx]];
    idx += 1;
  }
  return vals;
});
var values$1 = values2;
function _isFunction(x2) {
  var type3 = Object.prototype.toString.call(x2);
  return type3 === "[object Function]" || type3 === "[object AsyncFunction]" || type3 === "[object GeneratorFunction]" || type3 === "[object AsyncGeneratorFunction]";
}
var type = _curry1(function type2(val) {
  return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
});
function _pipe(f, g) {
  return function() {
    return g.call(this, f.apply(this, arguments));
  };
}
function _checkForMethod(methodname, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}
var slice = _curry3(
  _checkForMethod("slice", function slice2(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  })
);
var tail = _curry1(
  _checkForMethod(
    "tail",
    slice(1, Infinity)
  )
);
var tail$1 = tail;
function pipe() {
  if (arguments.length === 0) {
    throw new Error("pipe requires at least one argument");
  }
  return _arity(arguments[0].length, reduce$1(_pipe, arguments[0], tail$1(arguments)));
}
function _arrayFromIterator(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}
function _includesWith(pred, x2, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (pred(x2, list[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}
function _functionName(f) {
  var match = String(f).match(/^function (\w*)/);
  return match == null ? "" : match[1];
}
function _objectIs(a, b) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  } else {
    return a !== a && b !== b;
  }
}
var _objectIs$1 = typeof Object.is === "function" ? Object.is : _objectIs;
function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);
  var b = _arrayFromIterator(bIterator);
  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  }
  return !_includesWith(function(b2, aItem) {
    return !_includesWith(eq, aItem, b2);
  }, b, a);
}
function _equals(a, b, stackA, stackB) {
  if (_objectIs$1(a, b)) {
    return true;
  }
  var typeA = type(a);
  if (typeA !== type(b)) {
    return false;
  }
  if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
    return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
  }
  if (typeof a.equals === "function" || typeof b.equals === "function") {
    return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
  }
  switch (typeA) {
    case "Arguments":
    case "Array":
    case "Object":
      if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
        return a === b;
      }
      break;
    case "Boolean":
    case "Number":
    case "String":
      if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case "Date":
      if (!_objectIs$1(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case "Error":
      return a.name === b.name && a.message === b.message;
    case "RegExp":
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }
      break;
  }
  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }
  switch (typeA) {
    case "Map":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
    case "Set":
      if (a.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
    case "Arguments":
    case "Array":
    case "Object":
    case "Boolean":
    case "Number":
    case "String":
    case "Date":
    case "Error":
    case "RegExp":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "ArrayBuffer":
      break;
    default:
      return false;
  }
  var keysA = keys2(a);
  if (keysA.length !== keys2(b).length) {
    return false;
  }
  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}
var equals = _curry2(function equals2(a, b) {
  return _equals(a, b, [], []);
});
function _indexOf(list, a, idx) {
  var inf, item;
  if (typeof list.indexOf === "function") {
    switch (typeof a) {
      case "number":
        if (a === 0) {
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === "number" && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        return list.indexOf(a, idx);
      case "string":
      case "boolean":
      case "function":
      case "undefined":
        return list.indexOf(a, idx);
      case "object":
        if (a === null) {
          return list.indexOf(a, idx);
        }
    }
  }
  while (idx < list.length) {
    if (equals(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}
function _includes(a, list) {
  return _indexOf(list, a, 0) >= 0;
}
function _quote(s) {
  var escaped = s.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
  return '"' + escaped.replace(/"/g, '\\"') + '"';
}
var pad = function pad2(n) {
  return (n < 10 ? "0" : "") + n;
};
var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
  return d.toISOString();
} : function _toISOString3(d) {
  return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
};
function _complement(f) {
  return function() {
    return !f.apply(this, arguments);
  };
}
function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];
  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
}
function _isObject(x2) {
  return Object.prototype.toString.call(x2) === "[object Object]";
}
var XFilter = function() {
  function XFilter2(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFilter2.prototype["@@transducer/init"] = _xfBase.init;
  XFilter2.prototype["@@transducer/result"] = _xfBase.result;
  XFilter2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
  };
  return XFilter2;
}();
var _xfilter = _curry2(function _xfilter2(f, xf) {
  return new XFilter(f, xf);
});
var filter$1 = _curry2(
  _dispatchable(["fantasy-land/filter", "filter"], _xfilter, function(pred, filterable) {
    return _isObject(filterable) ? _reduce(function(acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }
      return acc;
    }, {}, keys2(filterable)) : (
      // else
      _filter(pred, filterable)
    );
  })
);
var reject = _curry2(function reject2(pred, filterable) {
  return filter$1(_complement(pred), filterable);
});
function _toString(x2, seen) {
  var recur = function recur2(y2) {
    var xs = seen.concat([x2]);
    return _includes(y2, xs) ? "<Circular>" : _toString(y2, xs);
  };
  var mapPairs = function(obj, keys5) {
    return _map(function(k) {
      return _quote(k) + ": " + recur(obj[k]);
    }, keys5.slice().sort());
  };
  switch (Object.prototype.toString.call(x2)) {
    case "[object Arguments]":
      return "(function() { return arguments; }(" + _map(recur, x2).join(", ") + "))";
    case "[object Array]":
      return "[" + _map(recur, x2).concat(mapPairs(x2, reject(function(k) {
        return /^\d+$/.test(k);
      }, keys2(x2)))).join(", ") + "]";
    case "[object Boolean]":
      return typeof x2 === "object" ? "new Boolean(" + recur(x2.valueOf()) + ")" : x2.toString();
    case "[object Date]":
      return "new Date(" + (isNaN(x2.valueOf()) ? recur(NaN) : _quote(_toISOString(x2))) + ")";
    case "[object Null]":
      return "null";
    case "[object Number]":
      return typeof x2 === "object" ? "new Number(" + recur(x2.valueOf()) + ")" : 1 / x2 === -Infinity ? "-0" : x2.toString(10);
    case "[object String]":
      return typeof x2 === "object" ? "new String(" + recur(x2.valueOf()) + ")" : _quote(x2);
    case "[object Undefined]":
      return "undefined";
    default:
      if (typeof x2.toString === "function") {
        var repr = x2.toString();
        if (repr !== "[object Object]") {
          return repr;
        }
      }
      return "{" + mapPairs(x2, keys2(x2)).join(", ") + "}";
  }
}
var toString = _curry1(function toString2(val) {
  return _toString(val, []);
});
var curry = _curry1(function curry2(fn) {
  return curryN(fn.length, fn);
});
var curry$1 = curry;
var invoker = _curry2(function invoker2(arity, method) {
  return curryN(arity + 1, function() {
    var target = arguments[arity];
    if (target != null && _isFunction(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
  });
});
var invoker$1 = invoker;
var is = _curry2(function is2(Ctor, val) {
  return val instanceof Ctor || val != null && (val.constructor === Ctor || Ctor.name === "Object" && typeof val === "object");
});
var is$1 = is;
var join = invoker$1(1, "join");
var join$1 = join;
var mergeWithKey = _curry3(function mergeWithKey2(fn, l, r) {
  var result = {};
  var k;
  for (k in l) {
    if (_has(k, l)) {
      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }
  for (k in r) {
    if (_has(k, r) && !_has(k, result)) {
      result[k] = r[k];
    }
  }
  return result;
});
var mergeDeepWithKey = _curry3(function mergeDeepWithKey2(fn, lObj, rObj) {
  return mergeWithKey(function(k, lVal, rVal) {
    if (_isObject(lVal) && _isObject(rVal)) {
      return mergeDeepWithKey2(fn, lVal, rVal);
    } else {
      return fn(k, lVal, rVal);
    }
  }, lObj, rObj);
});
var mergeDeepLeft = _curry2(function mergeDeepLeft2(lObj, rObj) {
  return mergeDeepWithKey(function(k, lVal, rVal) {
    return lVal;
  }, lObj, rObj);
});
var mergeDeepLeft$1 = mergeDeepLeft;
var omit = _curry2(function omit2(names, obj) {
  var result = {};
  var index2 = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    index2[names[idx]] = 1;
    idx += 1;
  }
  for (var prop3 in obj) {
    if (!index2.hasOwnProperty(prop3)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});
var omit$1 = omit;
var pickBy = _curry2(function pickBy2(test, obj) {
  var result = {};
  for (var prop3 in obj) {
    if (test(obj[prop3], prop3, obj)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});
var pickBy$1 = pickBy;
var split = invoker$1(1, "split");
var split$1 = split;
var toLower = invoker$1(0, "toLowerCase");
var toLower$1 = toLower;
var zipObj = _curry2(function zipObj2(keys5, values4) {
  var idx = 0;
  var len = Math.min(keys5.length, values4.length);
  var out = {};
  while (idx < len) {
    out[keys5[idx]] = values4[idx];
    idx += 1;
  }
  return out;
});
var zipObj$1 = zipObj;
pipe(toLower$1, split$1(" "), join$1("-"));
var getCol = curry$1((col, df) => {
  if (is$1(Number)) {
    return map$2((v) => nth$1(col, v) || "", df).filter((x2) => x2 !== "");
  }
  return map$2(prop$1(col), df);
});
var mapKeys = (fn, data2) => zipObj$1(map$2(fn, keys2(data2)), values$1(data2));
var kebabize = (str) => {
  return str.split("").map((letter, idx) => {
    return letter.toUpperCase() === letter ? `${idx !== 0 ? "-" : ""}${letter.toLowerCase()}` : letter;
  }).join("");
};
function ascending$1(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function descending$1(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending$1;
    compare2 = (d, x2) => ascending$1(f(d), x2);
    delta = (d, x2) => f(d) - x2;
  } else {
    compare1 = f === ascending$1 || f === descending$1 ? f : zero$1;
    compare2 = f;
    delta = f;
  }
  function left2(a, x2, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a, x2, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a, x2, lo = 0, hi = a.length) {
    const i = left2(a, x2, lo, hi - 1);
    return i > lo && delta(a[i - 1], x2) > -delta(a[i], x2) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero$1() {
  return 0;
}
function number$2(x2) {
  return x2 === null ? NaN : +x2;
}
var ascendingBisect = bisector(ascending$1);
var bisectRight = ascendingBisect.right;
var bisectCenter = bisector(number$2).center;
function extent(values4, valueof) {
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value of values4) {
      if (value != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value of values4) {
      if ((value = valueof(value, ++index2, values4)) != null) {
        if (min2 === void 0) {
          if (value >= value)
            min2 = max2 = value;
        } else {
          if (min2 > value)
            min2 = value;
          if (max2 < value)
            max2 = value;
        }
      }
    }
  }
  return [min2, max2];
}
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function max$1(values4, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value of values4) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values4) {
      if ((value = valueof(value, ++index2, values4)) != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min$1(values4, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value of values4) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values4) {
      if ((value = valueof(value, ++index2, values4)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start + i * step;
  }
  return range2;
}
function initRange(domain2, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain2);
      break;
    default:
      this.range(range2).domain(domain2);
      break;
  }
  return this;
}
function initInterpolator(domain2, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain2 === "function")
        this.interpolator(domain2);
      else
        this.range(domain2);
      break;
    }
    default: {
      this.domain(domain2);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
var implicit = Symbol("implicit");
function ordinal() {
  var index2 = new InternMap(), domain2 = [], range2 = [], unknown = implicit;
  function scale(d) {
    let i = index2.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d, i = domain2.push(d) - 1);
    }
    return range2[i % range2.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain2.slice();
    domain2 = [], index2 = new InternMap();
    for (const value of _) {
      if (index2.has(value))
        continue;
      index2.set(value, domain2.push(value) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain2, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function band() {
  var scale = ordinal().unknown(void 0), domain2 = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain2().length, reverse = r1 < r0, start = reverse ? r1 : r0, stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values4 = range(n).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse ? values4.reverse() : values4);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain2(_), rescale()) : domain2();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain2(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b)
    x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define(Lab, lab, extend(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl$1(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define(Hcl, hcl$1, extend(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));
var constant$3 = (x2) => () => x2;
function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y2) {
  return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t) {
    return Math.pow(a + t * b, y2);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y2) : constant$3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);
}
var rgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x2 = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = interpolate(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x2[i](t);
    return c;
  };
}
function date(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolate(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, rgb) : string : b instanceof color ? rgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}
function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
function hcl(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl$1(start)).h, (end = hcl$1(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var interpolateHcl = hcl(hue);
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$3(x2) {
  return x2;
}
function normalize$1(a, b) {
  return (b -= a = +a) ? function(x2) {
    return (x2 - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x2) {
    return Math.max(a, Math.min(b, x2));
  };
}
function bimap(domain2, range2, interpolate2) {
  var d0 = domain2[0], d1 = domain2[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize$1(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize$1(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain2, range2, interpolate2) {
  var j = Math.min(domain2.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain2[j] < domain2[0]) {
    domain2 = domain2.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize$1(domain2[i], domain2[i + 1]);
    r[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisectRight(domain2, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$1() {
  var domain2 = unit, range2 = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp = identity$3, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain2.length, range2.length);
    if (clamp !== identity$3)
      clamp = clamper(domain2[0], domain2[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain2.map(transform), range2, interpolate$1)))(transform(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise(range2, domain2.map(transform), interpolateNumber)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain2 = Array.from(_, number$1), rescale()) : domain2.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer$1()(identity$3, identity$3);
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}
function formatRounded(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
var formatTypes = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded(x2 * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$2(x2) {
  return x2;
}
var map2 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map2.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map2.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type3 = specifier.type;
    if (type3 === "n")
      comma = true, type3 = "g";
    else if (!formatTypes[type3])
      precision === void 0 && (precision = 12), trim = true, type3 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type3) ? "0" + type3.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type3) ? percent : "";
    var formatType = formatTypes[type3], maybeSuffix = /[defgprs%]/.test(type3);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type3) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type3 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type3 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain2 = scale.domain;
  scale.ticks = function(count2) {
    var d = domain2();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain2();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain2();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain2(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy$1(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function transformer() {
  var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$3, clamp = false, unknown;
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range2(interpolate2) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range2(interpolate);
  scale.rangeRound = range2(interpolateRound);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform = t, t02 = t(x0), t12 = t(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale;
  };
}
function copy(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer()(identity$3));
  scale.copy = function() {
    return copy(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
var Scale = class {
  constructor(config) {
    this.config = config;
    this.createScale(config.type);
  }
  createScale(type3) {
    switch (type3) {
      case "band":
        this.scale = band();
        break;
      case "linear":
        this.scale = linear();
        break;
    }
  }
  changeConfig(config) {
    this.createScale(config.type);
    this.config = config;
  }
  get type() {
    return this.config.type;
  }
  bandwidth() {
    if (this.type === "band") {
      return this.scale.bandwidth();
    }
    return 0;
  }
  updateRange(range2) {
    this.scale = this.scale.copy().range(range2);
  }
  updateDomain(data2, stackedData2, keys5) {
    const domain2 = this.config.type === "band" ? this.categoryDomain(data2, keys5) : this.numericDomain(data2, stackedData2, keys5);
    this.scale = this.scale.copy().domain(domain2);
  }
  map(values4) {
    return values4.map((v) => this.mapOne(v));
  }
  mapOne(val) {
    const { type: type3 } = this.config;
    if (type3 === "band") {
      return this.scale(val) + this.scale.bandwidth() / 2;
    }
    return this.scale(val);
  }
  ticks() {
    const { type: type3 } = this.config;
    if (this.config.tickValues !== void 0) {
      return this.config.tickValues;
    }
    if (type3 === "band") {
      return this.scale.domain();
    }
    return this.scale.ticks(this.config.ticks || 5);
  }
  categoryDomain(data2, keys5) {
    const values4 = keys5.reduce((arr, key) => arr.concat(getCol(key, data2)), []);
    return Array.from(new Set(values4));
  }
  numericDomain(data, stackedData, keys) {
    const { domain } = this.config;
    const values = keys.reduce((arr, key) => arr.concat(getCol(key, data)), []);
    const valueMax = max$1(stackedData, (arr) => max$1(arr, (x2) => max$1(x2))) || 0;
    const valueMin = min$1(stackedData, (arr) => min$1(arr, (x2) => min$1(x2))) || 0;
    const [dataMin, dataMax] = extent(Array.from(new Set(values.concat([valueMin, valueMax]))));
    const yMin = eval(`
      let dataMin = ${dataMin || 0}
      ${domain[0]}
    `);
    const yMax = eval(`
      let dataMax = ${dataMax || 0}
      ${domain[1]}
    `);
    return [yMin, yMax];
  }
};
var Scales = class {
  constructor(config) {
    this.config = config;
    this.primary = new Scale(config.primary);
    this.secondary = new Scale(config.secondary);
  }
  changeConfig(config) {
    this.config = config;
    this.primary.changeConfig(config.primary);
    this.secondary.changeConfig(config.secondary);
  }
  updateRange(canvas, direction) {
    if (direction === "horizontal") {
      this.primary.updateRange([canvas.x, canvas.width]);
      this.secondary.updateRange([canvas.height, canvas.y]);
    } else if (direction === "vertical") {
      this.primary.updateRange([canvas.y, canvas.height]);
      this.secondary.updateRange([canvas.x, canvas.width]);
    }
  }
  updateDomain(data2, stackedData2, keys5) {
    this.primary.updateDomain(data2, stackedData2, getCol(0, keys5));
    this.secondary.updateDomain(data2, stackedData2, getCol(1, keys5));
  }
};
function constant$2(x2) {
  return function constant2() {
    return x2;
  };
}
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon$2 = 1e-12;
var pi$1 = Math.PI;
var halfPi = pi$1 / 2;
var tau$1 = 2 * pi$1;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}
var pi = Math.PI;
var tau = 2 * pi;
var epsilon$1 = 1e-6;
var tauEpsilon = tau - epsilon$1;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d > 15)
    return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon$1))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon$1) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
      this._append`L${x0},${y0}`;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon$1) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w, h) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
};
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length)
      return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$2)
    return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path = withPath(arc2);
  function arc2() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer = path();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon$2))
      context.moveTo(0, 0);
    else if (da > tau$1 - epsilon$2) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$2) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$2) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon$2)
          p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$2)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon$2) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi$1) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min(rc, (r0 - lc) / (kc - 1));
            rc1 = min(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon$2))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon$2) {
        t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon$2) || !(da0 > epsilon$2))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon$2) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc2.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
    return [cos(a) * r, sin(a) * r];
  };
  arc2.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$2(+_), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), arc2) : padRadius;
  };
  arc2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : startAngle;
  };
  arc2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : endAngle;
  };
  arc2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), arc2) : padAngle;
  };
  arc2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc2) : context;
  };
  return arc2;
}
function array$1(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
function line(x$1, y$1) {
  var defined = constant$2(true), context = null, curve = curveLinear, output = null, path = withPath(line2);
  x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant$2(x$1);
  y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant$2(y$1);
  function line2(data2) {
    var i, n = (data2 = array$1(data2)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x$1(d, i, data2), +y$1(d, i, data2));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line2.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$2(+_), line2) : x$1;
  };
  line2.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$2(+_), line2) : y$1;
  };
  line2.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), line2) : defined;
  };
  line2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
  };
  return line2;
}
function area(x0, y0, y1) {
  var x1 = null, defined = constant$2(true), context = null, curve = curveLinear, output = null, path = withPath(area2);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant$2(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$2(0) : constant$2(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant$2(+y1);
  function area2(data2) {
    var i, j, k, n = (data2 = array$1(data2)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data2), y0z[i] = +y0(d, i, data2);
        output.point(x1 ? +x1(d, i, data2) : x0z[i], y1 ? +y1(d, i, data2) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }
  area2.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), x1 = null, area2) : x0;
  };
  area2.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$2(+_), area2) : x0;
  };
  area2.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area2) : x1;
  };
  area2.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), y1 = null, area2) : y0;
  };
  area2.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$2(+_), area2) : y0;
  };
  area2.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$2(+_), area2) : y1;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area2.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area2.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area2.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$2(!!_), area2) : defined;
  };
  area2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
  };
  return area2;
}
function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
function identity$1(d) {
  return d;
}
function pie() {
  var value = identity$1, sortValues = descending, sort = null, startAngle = constant$2(0), endAngle = constant$2(tau$1), padAngle = constant$2(0);
  function pie2(data2) {
    var i, n = (data2 = array$1(data2)).length, j, k, sum = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index2[i] = i] = +value(data2[i], i, data2)) > 0) {
        sum += v;
      }
    }
    if (sortValues != null)
      index2.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
    else if (sort != null)
      index2.sort(function(i2, j2) {
        return sort(data2[i2], data2[j2]);
      });
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index2[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data2[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie2.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), pie2) : value;
  };
  pie2.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie2) : sortValues;
  };
  pie2.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie2) : sort;
  };
  pie2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$2(+_), pie2) : startAngle;
  };
  pie2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$2(+_), pie2) : endAngle;
  };
  pie2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$2(+_), pie2) : padAngle;
  };
  return pie2;
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a = new Array(n), b = new Array(n), r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a[i + 1];
  return [a, b];
}
function curveNatural(context) {
  return new Natural(context);
}
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context) {
  return new Step(context, 0.5);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function none$1(series, order) {
  if (!((n = series.length) > 1))
    return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
function stackOrderNone(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}
function stackValue(d, key) {
  return d[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function stack() {
  var keys5 = constant$2([]), order = stackOrderNone, offset = none$1, value = stackValue;
  function stack2(data2) {
    var sz = Array.from(keys5.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
    for (const d of data2) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data2)]).data = d;
      }
    }
    for (i = 0, oz = array$1(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack2.keys = function(_) {
    return arguments.length ? (keys5 = typeof _ === "function" ? _ : constant$2(Array.from(_)), stack2) : keys5;
  };
  stack2.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$2(+_), stack2) : value;
  };
  stack2.order = function(_) {
    return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant$2(Array.from(_)), stack2) : order;
  };
  stack2.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none$1 : _, stack2) : offset;
  };
  return stack2;
}
var defaultConfig = {
  size: { width: 500, height: 400 },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  direction: "horizontal",
  axis: {
    primary: {
      domain: ["dataMin", "dataMax"],
      type: "band"
    },
    secondary: {
      domain: ["dataMin", "dataMax"],
      type: "linear"
    }
  },
  axisSpace: {
    x: 40,
    y: 20
  }
};
var Chart = class {
  constructor(data2, config) {
    this.data = data2;
    this.layers = [];
    this.config = mergeDeepLeft$1(pickBy$1((p) => p !== void 0, config), defaultConfig);
    this.scales = new Scales(this.config.axis);
    this.updates = ref(0);
  }
  get bandScale() {
    if (this.scales.primary.type === "band")
      return this.scales.primary;
    if (this.scales.secondary.type === "band")
      return this.scales.secondary;
    return null;
  }
  get canvas() {
    const { margin, size } = this.config;
    const axisSpace = this.config.axisSpace;
    if (this.config.axis.primary.hide) {
      axisSpace.y = 0;
    }
    if (this.config.axis.secondary.hide) {
      axisSpace.x = 0;
    }
    return {
      x: margin.left + axisSpace.x,
      y: margin.top,
      width: size.width - margin.right,
      height: size.height - margin.bottom - axisSpace.y
    };
  }
  getStackedData(keys5) {
    return stack().keys(keys5).order(stackOrderNone)(this.data);
  }
  changeData(data2) {
    this.data = data2;
    this.update("data");
  }
  changeConfig(config) {
    this.config = mergeDeepLeft$1(pickBy$1((p) => p !== void 0, config), this.config);
    this.scales.changeConfig(this.config.axis);
    this.update("config");
  }
  addLayer(layer) {
    this.layers.push(layer);
    this.update("layers");
  }
  removeLayer(id) {
    this.layers = this.layers.filter((l) => l.id !== id);
    this.update("layers");
  }
  getLayers(type3) {
    if (type3) {
      return this.layers.filter((l) => l.type === type3);
    }
    return this.layers;
  }
  getData(keys5) {
    return keys5.reduce((arr, key) => arr.concat(getCol(key, this.data)), []);
  }
  getKeys(idx = -1, type3 = null) {
    const keys5 = this.layers.filter((l) => {
      if (type3)
        return l.type === type3;
      return true;
    }).map((l) => l.dataKeys);
    if (idx === -1) {
      return keys5;
    }
    return getCol(idx, keys5);
  }
  getStackedKeys(idx = -1, type3 = null) {
    const keys5 = this.layers.filter((l) => {
      if (type3)
        return l.type === type3 && l.props.stacked;
      return l.props.stacked;
    }).map((l) => l.dataKeys);
    if (idx === -1) {
      return keys5;
    }
    return getCol(idx, keys5);
  }
  update(_) {
    const stackedData2 = this.getStackedData(this.getStackedKeys(1));
    this.scales.updateRange(this.canvas, this.config.direction);
    this.scales.updateDomain(this.data, stackedData2, this.getKeys());
    this.updates.value += 1;
  }
};
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function array(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$1(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data2) {
  var i = 0, node, groupLength = group.length, dataLength = data2.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data2[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data2[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data2, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data2[i], i, data2) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data2[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data2[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind3 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$1(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data2 = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data2.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind3(parent, group, enterGroup, updateGroup, exitGroup, data2, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data2) {
  return typeof data2 === "object" && "length" in data2 ? data2 : Array.from(data2);
}
function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent(node, type3, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type3, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type3, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type3, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params);
  };
}
function dispatchFunction(type3, params) {
  return function() {
    return dispatchEvent(this, type3, params.apply(this, arguments));
  };
}
function selection_dispatch(type3, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type3, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection_selection() {
  return this;
}
Selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer(event, node) {
  event = sourceEvent(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      point2.x = event.clientX, point2.y = event.clientY;
      point2 = point2.matrixTransform(node.getScreenCTM().inverse());
      return [point2.x, point2.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
function identity(x2) {
  return x2;
}
var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;
function translateX(x2) {
  return "translate(" + x2 + ",0)";
}
function translateY(y2) {
  return "translate(0," + y2 + ")";
}
function number(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values4 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position = (scale.bandwidth ? center : number)(scale.copy(), offset), selection = context.selection ? context.selection() : context, path = selection.selectAll(".domain").data([null]), tick = selection.selectAll(".tick").data(values4, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform(position(d) + offset);
    });
    line2.attr(x2 + "2", k * tickSizeInner);
    text.attr(x2, k * spacing).text(format2);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
var useChart = () => {
  const chart = inject("chart");
  return chart;
};
var usePoints = (dataKeys, props = { stacked: false, type: "line" }) => {
  const points = ref([]);
  const chart = useChart();
  const { stacked, type: type3 } = props;
  function getPoints(key, values4) {
    const { primary, secondary } = chart.scales;
    if (chart.config.direction === "horizontal") {
      const res = values4.map((val) => {
        return {
          x: primary.mapOne(val.data[key]),
          y: secondary.mapOne(val[1]),
          props: { values: [...val], data: val.data }
        };
      }).filter((p) => !isNaN(p.x) && !isNaN(p.y));
      return res;
    } else if (chart.config.direction === "vertical") {
      return values4.map((val) => {
        return {
          x: secondary.mapOne(val[1]),
          y: primary.mapOne(val.data[key]),
          props: { values: [...val], data: val.data }
        };
      }).filter((p) => !isNaN(p.x) && !isNaN(p.y));
    }
    return [];
  }
  function update() {
    const keys5 = chart.getStackedKeys(1, type3);
    const [primaryKey, secondaryKey] = dataKeys;
    const stack2 = chart.getStackedData(stacked ? keys5 : [dataKeys[1]]);
    const data2 = stack2.find((s) => s.key === secondaryKey);
    if (data2) {
      points.value = getPoints(primaryKey, data2);
    }
  }
  watch(chart.updates, () => {
    update();
  }, { immediate: true });
  return {
    points
  };
};
var useMouse = () => {
  const mouse = inject("chartMouse", {
    index: -1,
    position: { x: 0, y: 0 },
    hover: false
  });
  return mouse;
};
var useBars = (dataKeys, props = { maxWidth: -1, gap: 5, stacked: false, type: "bar" }) => {
  const bars = ref([]);
  const chart = useChart();
  const { stacked, type: type3, gap } = props;
  function scales() {
    const { primary, secondary } = chart.scales;
    const bandScale = primary.type === "band" ? primary : secondary;
    const linearScale = primary.type === "band" ? secondary : primary;
    return { bandScale, linearScale };
  }
  function getIndex() {
    if (stacked) {
      return 0;
    }
    const barLayers = chart.getLayers(type3);
    const idx = barLayers.findIndex((l) => l.dataKeys.join(",") === dataKeys.join(","));
    return idx > -1 ? idx : 0;
  }
  function getBarWidth() {
    const { bandScale } = scales();
    const maxWidth = props.maxWidth > -1 ? Math.min(bandScale.bandwidth() - gap, props.maxWidth) : bandScale.bandwidth() - gap;
    const barLayers = chart.getLayers(type3);
    return barLayers.length > 0 && !stacked ? maxWidth / barLayers.length : maxWidth;
  }
  function getDiffWidth() {
    if (stacked) {
      return 0;
    }
    const { bandScale } = scales();
    const max2 = bandScale.bandwidth() - gap;
    const total = chart.getLayers(type3).length * getBarWidth();
    return (max2 - total) / 2;
  }
  function getBars(key, values4) {
    const { bandScale, linearScale } = scales();
    const index2 = getIndex();
    const barSize = getBarWidth();
    const diff = getDiffWidth();
    return values4.map((val) => {
      const rect = { x: 0, y: 0, width: 0, height: 0, props: { values: [...val], data: val.data } };
      const xVal = bandScale.scale(val.data[key]);
      const [yVal0, yVal1] = linearScale.map(val);
      if (chart.config.direction === "horizontal") {
        rect.y = Math.min(yVal0, yVal1);
        rect.height = Math.abs(yVal0 - yVal1);
        rect.x = diff + xVal + index2 * barSize + gap / 2;
        rect.width = barSize;
      } else if (chart.config.direction === "vertical") {
        rect.x = Math.min(yVal0, yVal1);
        rect.width = Math.abs(yVal0 - yVal1);
        rect.y = diff + xVal + index2 * barSize + gap / 2;
        rect.height = barSize;
      }
      return rect;
    });
  }
  function update() {
    const keys5 = stacked ? chart.getStackedKeys(1, type3) : [dataKeys[1]];
    const [primaryKey, secondaryKey] = dataKeys;
    const stack2 = chart.getStackedData(keys5);
    const data2 = stack2.find((s) => s.key === secondaryKey);
    if (data2) {
      bars.value = getBars(primaryKey, data2);
    }
  }
  watch(chart.updates, () => {
    update();
  });
  return {
    bars
  };
};
var useTooltip = () => {
  const mouse = useMouse();
  const chart = useChart();
  const show = computed(() => mouse.hover);
  const position = ref({ x: 0, y: 0 });
  const payload = ref({});
  watch(mouse, () => {
    const { primary } = chart.scales;
    const keys5 = chart.getKeys(0);
    const vals = chart.getData(keys5);
    const [x2] = primary.map([vals[mouse.index]]);
    if (x2) {
      if (chart.config.direction === "horizontal") {
        position.value = {
          x: x2,
          y: mouse.position.y
        };
      } else if (chart.config.direction === "vertical") {
        position.value = {
          x: mouse.position.x,
          y: x2
        };
      } else {
        position.value = {
          x: mouse.position.x,
          y: mouse.position.y
        };
      }
    }
    const d = chart.data[mouse.index];
    if (d) {
      payload.value = Object.assign(Object.assign({}, d), { idx: mouse.index });
    }
  });
  return { position, payload, show };
};
var useResize = (el) => {
  const width = ref(0);
  const height = ref(0);
  let observer = null;
  let resizeCallback = null;
  function onUpdate(w, h) {
    width.value = w;
    height.value = h;
    if (resizeCallback) {
      resizeCallback();
    }
  }
  function onResize(callback) {
    resizeCallback = callback;
  }
  onMounted(() => {
    observer = new window.ResizeObserver((entries) => {
      const w = entries[0].contentRect.width;
      const h = entries[0].contentRect.height;
      onUpdate(w, h);
    });
    observer.observe(el.value);
  });
  onUnmounted(() => {
    observer.disconnect();
  });
  return { width, height, onResize };
};
var script$d = defineComponent({
  name: "Axis",
  props: {
    position: {
      type: String,
      default: "bottom"
    },
    rotate: {
      type: Boolean,
      default: false
    },
    isPrimary: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const el = ref();
    const chart = useChart();
    const axis2 = computed(() => {
      return props.position === "bottom" ? axisBottom : axisLeft;
    });
    const canvas = ref(chart.canvas);
    const defaultConfig2 = { ticks: 5 };
    function drawAxis() {
      if (chart.data.length > 0) {
        const { primary, secondary } = chart.scales;
        const current = props.isPrimary ? primary : secondary;
        const config = Object.assign({}, props.isPrimary ? primary.config : secondary.config, defaultConfig2);
        const ax = axis2.value(current.scale);
        if (config.format) {
          ax.tickFormat(config.format);
        }
        if (config.ticks !== void 0) {
          ax.ticks(config.ticks);
        }
        if (config.tickValues !== void 0) {
          ax.tickValues(config.tickValues);
        }
        if (config.useConfig) {
          config.useConfig(ax);
        }
        const res = select(el.value).call(ax);
        if (props.position === "bottom" && props.rotate) {
          res.selectAll("text").attr("y", 0).attr("x", 9).attr("dy", ".35em").attr("transform", "rotate(90)").style("text-anchor", "start");
        }
        return ax;
      }
      return null;
    }
    watch(() => props.isPrimary, () => {
      drawAxis();
    });
    watch(chart.updates, () => {
      canvas.value = chart.canvas;
      drawAxis();
    });
    return { el, canvas };
  }
});
var _hoisted_1$b = ["transform"];
var _hoisted_2$8 = ["transform"];
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.position === "bottom" ? (openBlock(), createElementBlock("g", {
    key: 0,
    class: normalizeClass(`layer-axis-x`),
    ref: "el",
    transform: `translate(0, ${_ctx.canvas.height})`
  }, null, 8, _hoisted_1$b)) : (openBlock(), createElementBlock("g", {
    key: 1,
    class: normalizeClass(`layer-axis-y`),
    ref: "el",
    transform: `translate(${_ctx.canvas.x}, 0)`
  }, null, 8, _hoisted_2$8));
}
script$d.render = render$d;
script$d.__file = "src/components/Axis/index.vue";
var script$c = defineComponent({
  name: "Chart",
  components: { Axis: script$d },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    margin: {
      type: Object,
      default: () => ({
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }),
      required: false
    },
    size: {
      type: Object,
      default: () => ({ width: 500, height: 400 }),
      required: false
    },
    direction: {
      type: String,
      default: "horizontal",
      required: false
    },
    axis: {
      type: Object,
      required: false
    },
    config: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const chartEl = ref(null);
    const axLeftEl = ref();
    const axBottomEl = ref();
    const axisSpace = reactive({ x: 40, y: 20 });
    const chart = new Chart(props.data, props.config);
    const rotateX = computed(() => props.axis && props.axis.primary && props.axis.primary.rotate);
    const hideX = computed(() => {
      return props.axis && props.axis.primary && props.axis.primary.hide;
    });
    const hideY = computed(() => {
      return props.axis && props.axis.secondary && props.axis.secondary.hide;
    });
    const mouse = reactive({
      index: -1,
      position: { x: 0, y: 0 },
      hover: false
    });
    provide("chart", chart);
    provide("chartMouse", mouse);
    watch(() => props.data, () => {
      if (chart)
        chart.changeData(props.data);
    }, { immediate: true });
    watch(() => props.config, () => {
      if (chart)
        chart.changeConfig(props.config);
    });
    watch(() => [Object.assign({}, axisSpace), props.direction, props.size, props.margin, props.axis], () => {
      if (chart) {
        chart.changeConfig({
          axisSpace: Object.assign({}, axisSpace),
          direction: props.direction,
          size: props.size,
          margin: props.margin,
          axis: props.axis
        });
      }
    }, { immediate: true });
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        if (axBottomEl.value && entry.target === axBottomEl.value.$el) {
          axisSpace.y = entry.contentRect.height;
        } else if (axLeftEl.value && entry.target === axLeftEl.value.$el) {
          axisSpace.x = entry.contentRect.width;
        }
      }
    });
    onMounted(() => {
      if (axBottomEl.value) {
        resizeObserver.observe(axBottomEl.value.$el);
      }
      if (axLeftEl.value) {
        resizeObserver.observe(axLeftEl.value.$el);
      }
    });
    onUnmounted(() => {
      resizeObserver.disconnect();
    });
    function onMouseOut() {
      if (props.config.controlHover === false) {
        return;
      }
      mouse.index = -1;
      mouse.hover = false;
    }
    function onMouseMove(e) {
      if (props.config.controlHover === false) {
        return;
      }
      mouse.hover = true;
      mouse.position = { x: pointer(e)[0], y: pointer(e)[1] };
      const { primary } = chart.scales;
      const keys5 = chart.getKeys(0);
      const vals = chart.getData(keys5);
      if (chart.config.direction === "horizontal") {
        if (primary.type === "band") {
          const band2 = primary.bandwidth();
          const delta = mouse.position.x - chart.canvas.x;
          mouse.index = Math.round((delta + band2 / 2) / band2) - 1;
        } else {
          mouse.index = bisectCenter(vals, primary.scale.invert(mouse.position.x));
        }
      } else if (chart.config.direction === "vertical") {
        if (primary.type === "band") {
          const band2 = primary.bandwidth();
          const delta = mouse.position.y - chart.canvas.y;
          mouse.index = Math.round((delta + band2 / 2) / band2) - 1;
        } else {
          mouse.index = bisectCenter(vals, primary.scale.invert(mouse.position.y));
        }
      }
    }
    return { axBottomEl, axLeftEl, chartEl, hideX, hideY, rotateX, onMouseMove, onMouseOut };
  }
});
var _hoisted_1$a = {
  class: "chart",
  ref: "chartEl"
};
var _hoisted_2$7 = ["width", "height", "viewBox"];
var _hoisted_3$6 = { class: "layers" };
var _hoisted_4$3 = { class: "axis" };
var _hoisted_5$3 = { class: "widgets" };
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_axis = resolveComponent("axis");
  return openBlock(), createElementBlock(
    "div",
    _hoisted_1$a,
    [
      (openBlock(), createElementBlock("svg", {
        width: _ctx.size.width,
        height: _ctx.size.height,
        viewBox: `0 0 ${_ctx.size.width} ${_ctx.size.height}`,
        onPointermove: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseMove && _ctx.onMouseMove(...args)),
        onPointerleave: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseOut && _ctx.onMouseOut(...args))
      }, [
        createBaseVNode("g", _hoisted_3$6, [
          renderSlot(_ctx.$slots, "layers")
        ]),
        createBaseVNode("g", _hoisted_4$3, [
          !_ctx.hideX ? (openBlock(), createBlock(_component_axis, {
            key: 0,
            position: "bottom",
            ref: "axBottomEl",
            rotate: _ctx.rotateX,
            isPrimary: _ctx.direction === "horizontal"
          }, null, 8, ["rotate", "isPrimary"])) : createCommentVNode("v-if", true),
          !_ctx.hideY ? (openBlock(), createBlock(_component_axis, {
            key: 1,
            position: "left",
            ref: "axLeftEl",
            isPrimary: _ctx.direction === "vertical"
          }, null, 8, ["isPrimary"])) : createCommentVNode("v-if", true)
        ])
      ], 40, _hoisted_2$7)),
      createBaseVNode("div", _hoisted_5$3, [
        renderSlot(_ctx.$slots, "widgets")
      ])
    ],
    512
    /* NEED_PATCH */
  );
}
function styleInject(css, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$1 = "\n.chart {\n  position: relative;\n}\n";
styleInject(css_248z$1);
script$c.render = render$c;
script$c.__file = "src/components/Chart/index.vue";
var script$b = defineComponent({
  name: "Layer",
  props: {
    type: {
      type: String,
      default: "custom"
    },
    dataKeys: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const chart = useChart();
    const id = (/* @__PURE__ */ new Date()).getTime().toString();
    const extraProps = inject("layerProps", {});
    onMounted(() => {
      chart.addLayer({ id, type: props.type, dataKeys: props.dataKeys, props: extraProps });
    });
    onUnmounted(() => {
      chart.removeLayer(id);
    });
    return {};
  }
});
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "g",
    {
      class: normalizeClass(`layer-${_ctx.type}`)
    },
    [
      renderSlot(_ctx.$slots, "default")
    ],
    2
    /* CLASS */
  );
}
script$b.render = render$b;
script$b.__file = "src/components/Layer/index.vue";
var script$a = defineComponent({
  name: "AreaComponent",
  components: { Layer: script$b },
  props: {
    areaStyle: {
      type: Object,
      required: false
    },
    dataKeys: {
      type: Object,
      required: true
    },
    type: {
      type: String,
      default: () => "normal"
    },
    gap: {
      type: Number,
      default: 0
    }
  },
  setup(props) {
    const chart = useChart();
    const { stacked } = inject("layerProps", { stacked: false });
    const { points } = usePoints(props.dataKeys, {
      stacked: false,
      type: "area"
    });
    const { bars } = useBars(props.dataKeys, {
      stacked,
      type: "area",
      gap: props.gap,
      maxWidth: -1
    });
    const d = ref("");
    const lineType = (type3) => {
      const map3 = {
        normal: curveLinear,
        natural: curveNatural,
        step: curveStep,
        monotone: chart.config.direction === "horizontal" ? monotoneX : monotoneY
      };
      return map3[type3];
    };
    const buildArea = () => {
      console.log(points.value);
      const { secondary } = chart.scales;
      if (stacked) {
        return area().curve(lineType(props.type)).x0((p) => p.x + p.width / 2).y0((p) => p.y).x1((p) => p.x + p.width / 2).y1((p) => p.y + p.height);
      }
      if (chart.config.direction === "vertical") {
        return area().curve(lineType(props.type)).y0((p) => p.y).y1((p) => p.y).x0((p) => p.x).x1(() => secondary.scale(0));
      }
      return area().curve(lineType(props.type)).x0((p) => p.x).x1((p) => p.x).y0((p) => p.y).y1(() => secondary.scale(0));
    };
    const getStyle = computed(() => {
      return () => Object.assign({ fill: "blue", fillOpacity: 0.25, stroke: "none" }, props.areaStyle);
    });
    const toKebabCase = (data2) => mapKeys(kebabize, data2);
    watch(points, () => {
      d.value = stacked ? buildArea()(bars.value) : buildArea()(points.value);
    });
    return { d, getStyle, toKebabCase };
  }
});
var _hoisted_1$9 = ["d"];
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createBlock(_component_Layer, {
    type: "area",
    dataKeys: _ctx.dataKeys
  }, {
    default: withCtx(() => [
      createBaseVNode("path", mergeProps(_ctx.toKebabCase(_ctx.getStyle()), { d: _ctx.d }), null, 16, _hoisted_1$9)
    ]),
    _: 1
    /* STABLE */
  }, 8, ["dataKeys"]);
}
script$a.render = render$a;
script$a.__file = "src/components/Area/index.vue";
var script$9 = defineComponent({
  name: "LineComponent",
  components: { Layer: script$b },
  props: {
    lineStyle: {
      type: Object,
      required: false
    },
    dotStyle: {
      type: Object,
      required: false
    },
    hideDot: {
      type: Boolean,
      default: false
    },
    dataKeys: {
      type: Object,
      required: true
    },
    type: {
      type: String,
      default: () => "normal"
    }
  },
  setup(props) {
    const { stacked } = inject("layerProps", { stacked: false });
    const mouse = useMouse();
    const chart = useChart();
    const d = ref("");
    const { points } = usePoints(props.dataKeys, { stacked, type: "line" });
    const lineType = {
      normal: curveLinear,
      natural: curveNatural,
      step: stepAfter,
      monotone: monotoneX
    };
    function updateLine() {
      let type3 = lineType[props.type];
      if (props.type === "monotone" && chart.config.direction === "vertical") {
        type3 = monotoneY;
      }
      d.value = line().x((p) => p.x).y((p) => p.y).curve(type3)(points.value);
    }
    function computeDotStyle(active) {
      const dotStyle = props.dotStyle;
      const style = getStyle.value();
      return Object.assign({ r: active ? 5 : 3, stroke: style.stroke, strokeWidth: style.strokeWidth, fill: "white" }, dotStyle);
    }
    const getStyle = computed(() => {
      if (is$1(Function, props.lineStyle)) {
        return props.lineStyle;
      }
      return () => Object.assign({ stroke: "#8884d8", strokeWidth: 2 }, props.lineStyle);
    });
    const getDotStyle = computed(() => {
      if (is$1(Function, props.dotStyle)) {
        return props.dotStyle;
      }
      return ({ active }) => computeDotStyle(active);
    });
    watch(points, () => updateLine());
    watch(chart.updates, () => updateLine());
    const toKebabCase = (data2) => mapKeys(kebabize, data2);
    return { d, mouse, points, toKebabCase, getStyle, getDotStyle };
  }
});
var _hoisted_1$8 = ["d"];
var _hoisted_2$6 = { key: 0 };
var _hoisted_3$5 = ["cx", "cy"];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createBlock(_component_Layer, {
    dataKeys: _ctx.dataKeys,
    type: "line"
  }, {
    default: withCtx(() => [
      createBaseVNode("path", mergeProps({ class: "chart-line" }, _ctx.toKebabCase(_ctx.getStyle()), {
        d: _ctx.d,
        fill: "none"
      }), null, 16, _hoisted_1$8),
      createCommentVNode(' :stroke="stroke"\n      :stroke-width="strokeWidth"\n      stroke-linejoin="round"\n      stroke-linecap="round" '),
      !_ctx.hideDot ? (openBlock(), createElementBlock("g", _hoisted_2$6, [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(_ctx.points, (c, i) => {
            return openBlock(), createElementBlock("circle", mergeProps(_ctx.toKebabCase(_ctx.getDotStyle({ active: i === _ctx.mouse.index, index: i })), {
              key: i,
              cx: c.x,
              cy: c.y
            }), null, 16, _hoisted_3$5);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  }, 8, ["dataKeys"]);
}
script$9.render = render$9;
script$9.__file = "src/components/Line/index.vue";
var script$8 = defineComponent({
  name: "Bar",
  components: { Layer: script$b },
  props: {
    selectedBar: {
      type: Object,
      default: () => null
    },
    barStyle: {
      type: [Function, Object],
      default: () => ({
        fill: "blue"
      })
    },
    barStyleSelected: {
      type: [Function, Object],
      default: () => ({
        fill: "darkblue"
      })
    },
    maxWidth: {
      type: Number,
      default: -1
    },
    dataKeys: {
      type: Object,
      required: true
    },
    gap: {
      type: Number,
      default: 5
    }
  },
  setup(props, { emit }) {
    const mouse = useMouse();
    const { stacked, maxWidth } = inject("layerProps", {
      stacked: false,
      maxWidth: -1
    });
    const { bars } = useBars(props.dataKeys, {
      maxWidth: Math.max(props.maxWidth, maxWidth),
      stacked,
      gap: props.gap,
      type: "bar"
    });
    const getStyle = computed(() => {
      if (is$1(Function, props.barStyle)) {
        return props.barStyle;
      }
      return () => props.barStyle;
    });
    const getStyleSelected = computed(() => {
      if (is$1(Function, props.barStyleSelected)) {
        return props.barStyleSelected;
      }
      return () => props.barStyleSelected;
    });
    const toKebabCase = (data2) => mapKeys(kebabize, data2);
    function onBarClick(bar, idx) {
      emit("barClick", Object.assign(Object.assign({}, bar), { idx }));
    }
    return { getStyle, getStyleSelected, toKebabCase, bars, mouse, onBarClick };
  }
});
var _hoisted_1$7 = { key: 0 };
var _hoisted_2$5 = ["x", "y", "width", "height", "onClick"];
var _hoisted_3$4 = ["x", "y", "width", "height"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createBlock(_component_Layer, {
    dataKeys: _ctx.dataKeys,
    type: "bar"
  }, {
    default: withCtx(() => [
      _ctx.bars.length === 0 ? (openBlock(), createElementBlock("text", _hoisted_1$7, "No Data")) : createCommentVNode("v-if", true),
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(_ctx.bars, (bar, i) => {
          return openBlock(), createElementBlock("rect", mergeProps(
            { class: "chart-bar" },
            _ctx.toKebabCase(_ctx.getStyle({ ...bar.props, active: i === _ctx.mouse.index })),
            {
              key: i,
              x: bar.x,
              y: bar.y,
              width: bar.width > 0 ? bar.width : 0,
              height: bar.height > 0 ? bar.height : 0,
              onClick: () => _ctx.onBarClick(bar, i)
            }
          ), null, 16, _hoisted_2$5);
        }),
        128
        /* KEYED_FRAGMENT */
      )),
      _ctx.selectedBar ? (openBlock(), createElementBlock("rect", mergeProps(
        {
          key: 1,
          class: "chart-bar"
        },
        _ctx.toKebabCase(_ctx.getStyleSelected({ ..._ctx.selectedBar.props })),
        {
          x: _ctx.selectedBar.x,
          y: _ctx.selectedBar.y,
          width: _ctx.selectedBar.width > 0 ? _ctx.selectedBar.width : 0,
          height: _ctx.selectedBar.height > 0 ? _ctx.selectedBar.height : 0
        }
      ), null, 16, _hoisted_3$4)) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  }, 8, ["dataKeys"]);
}
script$8.render = render$8;
script$8.__file = "src/components/Bar/index.vue";
var PieSort = String;
var script$7 = defineComponent({
  name: "PieLayer",
  components: { Layer: script$b },
  props: {
    pieStyle: {
      type: Object,
      required: false
    },
    dataKeys: {
      type: Object,
      required: true
    },
    sort: {
      type: PieSort,
      default: "desc",
      required: false
    },
    sortFunc: {
      type: Function,
      required: false
    }
  },
  setup(props) {
    var _a;
    const chart = useChart();
    const mouse = useMouse();
    const size = ref(Math.min(chart.canvas.width - chart.canvas.x, chart.canvas.height - chart.canvas.y) / 2);
    const getStyle = computed(() => {
      return () => Object.assign({ colors: ["#4daf4a", "#377eb8", "#ff7f00", "#984ea3", "#e41a1c"], innerRadius: 2, cornerRadius: 0, padAngle: 0.01 }, props.pieStyle);
    });
    const style = getStyle.value();
    const arcs = ref([]);
    const colors = ordinal(getStyle.value().colors);
    const arcGen = () => {
      return arc().outerRadius(size.value).innerRadius(style.innerRadius).cornerRadius(style.cornerRadius).padAngle(style.padAngle);
    };
    const transform = ref(`translate(${size.value + chart.canvas.x}, ${size.value + chart.canvas.y})`);
    let pieSort;
    switch (props.sort) {
      case "desc":
        pieSort = descending$1;
        break;
      case "asc":
        pieSort = ascending$1;
        break;
      case "none":
        pieSort = null;
        break;
      case "custom":
        pieSort = (_a = props.sortFunc) !== null && _a !== void 0 ? _a : null;
        break;
      default:
        pieSort = null;
    }
    function updatePie() {
      const data2 = chart.getData([props.dataKeys[1]]);
      arcs.value = pie().sort(pieSort)(data2);
    }
    function getColor(index2) {
      return colors(index2.toString());
    }
    function showTooltip(event, index2) {
      mouse.hover = true;
      mouse.index = index2;
      const [x2, y2] = pointer(event);
      mouse.position = { x: x2 + size.value, y: y2 + size.value };
    }
    function hideTooltip() {
      mouse.hover = false;
      mouse.index = -1;
    }
    function toKebabCase(data2) {
      mapKeys(kebabize, data2);
    }
    watch(chart.updates, () => {
      size.value = Math.min(chart.canvas.width - chart.canvas.x, (chart.canvas.height - chart.canvas.y) / 2);
      transform.value = `translate(${size.value + chart.canvas.x}, ${size.value + chart.canvas.y})`;
      updatePie();
    });
    return {
      arcs,
      arcGen,
      getStyle,
      transform,
      getColor,
      hideTooltip,
      toKebabCase,
      showTooltip
    };
  }
});
var _hoisted_1$6 = { key: 0 };
var _hoisted_2$4 = ["transform"];
var _hoisted_3$3 = ["id", "fill", "d", "onMousemove"];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Layer = resolveComponent("Layer");
  return openBlock(), createBlock(_component_Layer, {
    dataKeys: _ctx.dataKeys,
    type: "pie"
  }, {
    default: withCtx(() => [
      _ctx.arcs.length === 0 ? (openBlock(), createElementBlock("text", _hoisted_1$6, "No Data")) : createCommentVNode("v-if", true),
      createBaseVNode("g", { transform: _ctx.transform }, [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(_ctx.arcs, (arc2, i) => {
            return openBlock(), createElementBlock("path", mergeProps({
              key: i,
              id: `arc-${i}`,
              class: "chart-pie"
            }, _ctx.toKebabCase(_ctx.getStyle()), {
              fill: _ctx.getColor(i),
              d: _ctx.arcGen()(arc2),
              onMousemove: ($event) => _ctx.showTooltip($event, i),
              onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.hideTooltip())
            }), null, 16, _hoisted_3$3);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ], 8, _hoisted_2$4)
    ]),
    _: 1
    /* STABLE */
  }, 8, ["dataKeys"]);
}
script$7.render = render$7;
script$7.__file = "src/components/Pie/index.vue";
var script$6 = defineComponent({
  name: "Responsive",
  setup() {
    const el = ref(null);
    const { width, height } = useResize(el);
    return { el, width, height };
  }
});
var _hoisted_1$5 = { ref: "el" };
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    _hoisted_1$5,
    [
      renderSlot(_ctx.$slots, "main", {
        width: _ctx.width,
        height: _ctx.height
      })
    ],
    512
    /* NEED_PATCH */
  );
}
script$6.render = render$6;
script$6.__file = "src/components/Responsive/index.vue";
var script$5 = defineComponent({
  name: "Grid",
  props: {
    strokeDasharray: {
      type: String,
      default: () => "3 3"
    },
    hideX: {
      type: Boolean,
      default: false
    },
    hideY: {
      type: Boolean,
      default: false
    },
    center: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const chart = useChart();
    const data2 = ref([]);
    const canvas = ref(null);
    const xLines = ref([]);
    const yLines = ref([]);
    function updateXLines() {
      const { primary, secondary } = chart.scales;
      const current = chart.config.direction === "horizontal" ? secondary : primary;
      if (current.type === "band" && !props.center) {
        const vals = current.map(chart.getData(chart.getKeys(0))).map((x2) => x2 + current.bandwidth() / 2);
        vals.pop();
        xLines.value = vals;
      } else {
        const ticks2 = current.ticks();
        xLines.value = current.map(ticks2);
      }
    }
    function updateYLines() {
      const { primary, secondary } = chart.scales;
      const current = chart.config.direction === "horizontal" ? primary : secondary;
      if (current.type === "band" && !props.center) {
        const vals = current.map(chart.getData(chart.getKeys(0))).map((x2) => x2 + current.bandwidth() / 2);
        vals.pop();
        yLines.value = vals;
      } else {
        const ticks2 = current.ticks();
        yLines.value = current.map(ticks2);
      }
    }
    watch(chart.updates, () => {
      data2.value = chart.data;
      canvas.value = chart.canvas;
      updateXLines();
      updateYLines();
    });
    return { data: data2, canvas, xLines, yLines };
  }
});
var _hoisted_1$4 = ["stroke-dasharray"];
var _hoisted_2$3 = {
  key: 0,
  class: "grid-x"
};
var _hoisted_3$2 = ["x1", "y1", "x2", "y2"];
var _hoisted_4$2 = {
  key: 1,
  class: "grid-y"
};
var _hoisted_5$2 = ["x1", "y1", "x2", "y2"];
var _hoisted_6$2 = ["x1", "y1", "x2", "y2"];
var _hoisted_7 = ["x1", "y1", "x2", "y2"];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.data.length ? (openBlock(), createElementBlock("g", {
    key: 0,
    class: "layer-grid",
    stroke: "black",
    "stroke-opacity": "0.15",
    "stroke-width": "1",
    "stroke-dasharray": _ctx.strokeDasharray
  }, [
    !_ctx.hideX ? (openBlock(), createElementBlock("g", _hoisted_2$3, [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(_ctx.xLines, (y2, i) => {
          return openBlock(), createElementBlock("line", {
            key: i,
            x1: _ctx.canvas.x,
            y1: y2,
            x2: _ctx.canvas.width,
            y2
          }, null, 8, _hoisted_3$2);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ])) : createCommentVNode("v-if", true),
    !_ctx.hideY ? (openBlock(), createElementBlock("g", _hoisted_4$2, [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList(_ctx.yLines, (x2, i) => {
          return openBlock(), createElementBlock("line", {
            key: i,
            x1: x2,
            y1: _ctx.canvas.y,
            x2,
            y2: _ctx.canvas.height
          }, null, 8, _hoisted_5$2);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ])) : createCommentVNode("v-if", true),
    createBaseVNode("g", null, [
      createBaseVNode("line", {
        x1: _ctx.canvas.x,
        y1: _ctx.canvas.y,
        x2: _ctx.canvas.width,
        y2: _ctx.canvas.y
      }, null, 8, _hoisted_6$2),
      createBaseVNode("line", {
        x1: _ctx.canvas.width - 1,
        y1: _ctx.canvas.y,
        x2: _ctx.canvas.width - 1,
        y2: _ctx.canvas.height
      }, null, 8, _hoisted_7)
    ])
  ], 8, _hoisted_1$4)) : createCommentVNode("v-if", true);
}
script$5.render = render$5;
script$5.__file = "src/components/Grid/index.vue";
var script$4 = defineComponent({
  name: "Tooltip",
  components: {},
  props: {
    format: {
      type: String,
      default: ",.0f"
    },
    color: {
      type: String,
      default: "#7876ec"
    },
    hideLine: {
      type: Boolean,
      default: false
    },
    config: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const el = ref(null);
    const chart = useChart();
    const canvas = ref(chart.canvas);
    const direction = ref(chart.config.direction);
    const { position, payload, show } = useTooltip();
    const isRight = computed(() => {
      return position.value.x >= canvas.value.width / 4 * 3;
    });
    const style = computed(() => {
      if (direction.value === "vertical") {
        return {
          top: position.value.y - 0.5 + "px",
          left: canvas.value.x + "px"
        };
      } else if (direction.value === "horizontal") {
        return {
          top: canvas.value.y + "px",
          left: position.value.x - 0.5 + "px"
        };
      } else {
        return {
          top: canvas.value.y + "px",
          left: canvas.value.x + "px"
        };
      }
    });
    const styleContent = computed(() => {
      if (direction.value === "vertical") {
        return {
          top: "5px",
          left: position.value.x - 30 + "px"
        };
      } else if (direction.value === "horizontal") {
        return {
          top: position.value.y + "px",
          transform: `translateX(${isRight.value ? "-100%" : 0})`
        };
      } else {
        return {
          top: position.value.y + "px",
          left: position.value.x + "px"
        };
      }
    });
    const formatValue = (val, formatter) => {
      return is$1(Function, formatter) ? formatter(val) : is$1(Number, val) ? format(formatter)(val) : val;
    };
    const items = computed(() => {
      return Object.keys(omit$1(["idx"], payload.value)).map((key) => {
        const config = Object.assign({ label: key, format: props.format, color: props.color, hide: false }, props.config[key]);
        return {
          key,
          label: config.label,
          value: payload.value[key],
          valueFormatted: formatValue(payload.value[key], config.format),
          color: is$1(Function, config.color) ? config.color(payload.value) : config.color,
          hide: config.hide
        };
      }).filter((i) => !i.hide);
    });
    watch(chart.updates, () => {
      direction.value = chart.config.direction;
      canvas.value = chart.canvas;
    });
    return { el, show, canvas, direction, style, styleContent, position, items, isRight };
  }
});
var _hoisted_1$3 = { key: 0 };
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.show ? (openBlock(), createElementBlock(
    "div",
    {
      key: 0,
      class: "v-tooltip",
      style: normalizeStyle(_ctx.style)
    },
    [
      createBaseVNode(
        "div",
        {
          class: "v-tooltip-content",
          style: normalizeStyle(_ctx.styleContent),
          ref: "el"
        },
        [
          renderSlot(_ctx.$slots, "default", { payload: _ctx.items }, () => [
            createBaseVNode(
              "div",
              {
                style: normalizeStyle({ borderColor: _ctx.color })
              },
              [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(_ctx.items, (item, i) => {
                    return openBlock(), createElementBlock(
                      "div",
                      {
                        key: i,
                        style: normalizeStyle({ color: item.color })
                      },
                      [
                        createBaseVNode(
                          "b",
                          null,
                          toDisplayString(item.label),
                          1
                          /* TEXT */
                        ),
                        createTextVNode(
                          ": " + toDisplayString(item.valueFormatted),
                          1
                          /* TEXT */
                        )
                      ],
                      4
                      /* STYLE */
                    );
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ],
              4
              /* STYLE */
            )
          ])
        ],
        4
        /* STYLE */
      ),
      !_ctx.hideLine ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
        _ctx.direction === "horizontal" ? (openBlock(), createElementBlock(
          "div",
          {
            key: 0,
            class: "v-tooltip-line-vertical",
            style: normalizeStyle({
              height: _ctx.canvas.height + "px"
            })
          },
          null,
          4
          /* STYLE */
        )) : (openBlock(), createElementBlock(
          "div",
          {
            key: 1,
            class: "v-tooltip-line-horizontal",
            style: normalizeStyle({
              width: _ctx.canvas.width - 40 + "px"
            })
          },
          null,
          4
          /* STYLE */
        ))
      ])) : createCommentVNode("v-if", true)
    ],
    4
    /* STYLE */
  )) : createCommentVNode("v-if", true);
}
var css_248z = "\n.v-tooltip[data-v-43da20c6] {\n  position: absolute;\n  pointer-events: none;\n}\n.v-tooltip-content[data-v-43da20c6] {\n  position: absolute;\n  white-space: nowrap;\n  pointer-events: none;\n}\n.v-tooltip-content > div[data-v-43da20c6] {\n  margin-left: 5px;\n  margin-right: 5px;\n  border: 2px solid;\n  background-color: white;\n  padding: 8px;\n  text-align: left;\n  border-radius: 4px;\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n}\n.v-tooltip-right[data-v-43da20c6] {\n  transform: translateX(-100%);\n  margin-left: 0;\n}\n.v-tooltip-line-vertical[data-v-43da20c6] {\n  top: 0px;\n  position: absolute;\n  width: 1px;\n  background-color: black;\n  pointer-events: none;\n  opacity: 0.3;\n}\n.v-tooltip-line-horizontal[data-v-43da20c6] {\n  left: 0px;\n  position: absolute;\n  height: 1px;\n  background-color: black;\n  pointer-events: none;\n  opacity: 0.3;\n}\n";
styleInject(css_248z);
script$4.render = render$4;
script$4.__scopeId = "data-v-43da20c6";
script$4.__file = "src/components/Tooltip/index.vue";
var script$3 = defineComponent({
  props: {
    stacked: {
      type: Boolean,
      default: false
    },
    maxWidth: {
      type: Number,
      default: -1
    }
  },
  setup(props) {
    provide("layerProps", props);
  }
});
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$3.render = render$3;
script$3.__file = "src/components/Group/index.vue";
var script$2 = defineComponent({
  name: "Grid",
  props: {
    value: {
      type: Number
    },
    label: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "red"
    },
    strokeDasharray: {
      type: String,
      default: () => "3"
    },
    strokeWidth: {
      type: Number,
      default: 1
    },
    strokeOpacity: {
      type: Number,
      default: 0.5
    }
  },
  setup(props) {
    const chart = useChart();
    const y2 = ref(0);
    const direction = ref("horizontal");
    const canvas = ref({});
    watch(chart.updates, () => {
      if (props.value !== void 0) {
        y2.value = chart.scales.secondary.scale(props.value);
      }
      canvas.value = chart.canvas;
      direction.value = chart.config.direction;
    }, { immediate: true });
    watch(() => props.value, () => {
      y2.value = chart.scales.secondary.scale(props.value);
    }, { immediate: true });
    return { y: y2, canvas, direction };
  }
});
var _hoisted_1$2 = {
  key: 0,
  class: "layer-marker"
};
var _hoisted_2$2 = ["x", "y", "fill"];
var _hoisted_3$1 = ["x1", "y1", "x2", "y2", "stroke", "stroke-opacity", "stroke-width", "stroke-dasharray"];
var _hoisted_4$1 = {
  key: 1,
  class: "layer-marker"
};
var _hoisted_5$1 = ["x", "y", "fill"];
var _hoisted_6$1 = ["x1", "y1", "x2", "y2", "stroke", "stroke-opacity", "stroke-width", "stroke-dasharray"];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.direction === "horizontal" ? (openBlock(), createElementBlock("g", _hoisted_1$2, [
    createBaseVNode("text", {
      x: _ctx.canvas.x + 5,
      y: _ctx.y - 5,
      "text-anchor": "start",
      fill: _ctx.color
    }, toDisplayString(_ctx.label), 9, _hoisted_2$2),
    createBaseVNode("line", {
      x1: _ctx.canvas.x,
      y1: _ctx.y,
      x2: _ctx.canvas.width,
      y2: _ctx.y,
      stroke: _ctx.color,
      "stroke-opacity": _ctx.strokeOpacity,
      "stroke-width": _ctx.strokeWidth,
      "stroke-dasharray": _ctx.strokeDasharray
    }, null, 8, _hoisted_3$1)
  ])) : (openBlock(), createElementBlock("g", _hoisted_4$1, [
    createBaseVNode("text", {
      x: _ctx.y + 10,
      y: _ctx.canvas.y + 5,
      "text-anchor": "start",
      fill: _ctx.color,
      style: { "writing-mode": "tb" }
    }, toDisplayString(_ctx.label), 9, _hoisted_5$1),
    createBaseVNode("line", {
      x1: _ctx.y,
      y1: _ctx.canvas.y,
      x2: _ctx.y,
      y2: _ctx.canvas.height,
      stroke: _ctx.color,
      "stroke-opacity": _ctx.strokeOpacity,
      "stroke-width": _ctx.strokeWidth,
      "stroke-dasharray": _ctx.strokeDasharray
    }, null, 8, _hoisted_6$1)
  ]));
}
script$2.render = render$2;
script$2.__file = "src/components/Marker/index.vue";
function count(node) {
  var sum = 0, children2 = node.children, i = children2 && children2.length;
  if (!i)
    sum = 1;
  else
    while (--i >= 0)
      sum += children2[i].value;
  node.value = sum;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_eachBefore(callback, that) {
  var node = this, nodes = [node], children2, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}
function node_eachAfter(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_find(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}
function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0)
      sum += children2[i].value;
    node.value = sum;
  });
}
function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
function node_path(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b)
    return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}
function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
function node_descendants() {
  return Array.from(this);
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
function* node_iterator() {
  var node = this, current, next = [node], children2, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}
function hierarchy(data2, children2) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children2 === void 0)
      children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node(data2), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  find: node_find,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy,
  [Symbol.iterator]: node_iterator
};
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}
function constantZero() {
  return 0;
}
function constant(x2) {
  return function() {
    return x2;
  };
}
function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify() {
  var id = defaultId, parentId = defaultParentId, path;
  function stratify2(data2) {
    var nodes = Array.from(data2), currentId = id, currentParentId = parentId, n, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path != null) {
      const I = nodes.map((d2, i2) => normalize(path(d2, i2, data2)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_, i2) => I[i2];
      currentParentId = (_, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = currentId(d, i, data2)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data2)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    if (path != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed)
          break;
        node.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify2.id = function(x2) {
    return arguments.length ? (id = optional(x2), stratify2) : id;
  };
  stratify2.parentId = function(x2) {
    return arguments.length ? (parentId = optional(x2), stratify2) : parentId;
  };
  stratify2.path = function(x2) {
    return arguments.length ? (path = optional(x2), stratify2) : path;
  };
  return stratify2;
}
function normalize(path) {
  path = `${path}`;
  let i = path.length;
  if (slash(path, i - 1) && !slash(path, i - 2))
    path = path.slice(0, -1);
  return path[0] === "/" ? path : `/${path}`;
}
function parentof(path) {
  let i = path.length;
  if (i < 2)
    return "";
  while (--i > 1)
    if (slash(path, i))
      break;
  return path.slice(0, i);
}
function slash(path, i) {
  if (path[i] === "/") {
    let k = 0;
    while (i > 0 && path[--i] === "\\")
      ++k;
    if ((k & 1) === 0)
      return true;
  }
  return false;
}
function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else
      treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify = function custom(ratio) {
  function squarify2(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify2.ratio = function(x2) {
    return custom((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify2;
}(phi);
function treemap() {
  var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap2(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap2.round = function(x2) {
    return arguments.length ? (round = !!x2, treemap2) : round;
  };
  treemap2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap2) : [dx, dy];
  };
  treemap2.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap2) : tile;
  };
  treemap2.padding = function(x2) {
    return arguments.length ? treemap2.paddingInner(x2).paddingOuter(x2) : treemap2.paddingInner();
  };
  treemap2.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant(+x2), treemap2) : paddingInner;
  };
  treemap2.paddingOuter = function(x2) {
    return arguments.length ? treemap2.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap2.paddingTop();
  };
  treemap2.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant(+x2), treemap2) : paddingTop;
  };
  treemap2.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant(+x2), treemap2) : paddingRight;
  };
  treemap2.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant(+x2), treemap2) : paddingBottom;
  };
  treemap2.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant(+x2), treemap2) : paddingLeft;
  };
  return treemap2;
}
var script$1 = defineComponent({
  name: "Treemap",
  props: {
    size: {
      type: Object,
      default: () => ({ width: 500, height: 400 }),
      required: false
    },
    margin: {
      type: Object,
      default: () => ({ top: 0, right: 0, bottom: 0, left: 0 })
    },
    padding: {
      type: Number,
      default: 8
    },
    data: {
      type: Array,
      default: () => []
    },
    dataKeys: {
      type: Object,
      required: true
    },
    colorFn: {
      type: Function,
      default: () => interpolateHcl("#60c96e", "#6b46c1")
    },
    rcStyle: {
      type: Function,
      required: false
    }
  },
  setup(props) {
    const el = ref(null);
    const data2 = ref(props.data);
    const selected = ref(null);
    const canvas = ref({
      x: props.margin.left,
      y: props.margin.top,
      width: props.size.width - props.margin.right,
      height: props.size.height - props.margin.bottom
    });
    const rectangles = ref([]);
    function getScales() {
      const values4 = extent(data2.value.map((d) => d[props.dataKeys[1]]));
      const x2 = linear().domain(values4).range([0, 100]).nice();
      const y2 = sequential().domain(values4).interpolator(props.colorFn());
      return { x: x2, y: y2 };
    }
    function buildRectangles() {
      const { y: y2 } = getScales();
      const res = buildTree(data2.value).leaves().map((d, idx) => {
        return {
          idx,
          x0: canvas.value.x + d.x0,
          x1: canvas.value.x + d.x1,
          y0: canvas.value.y + d.y0,
          y1: canvas.value.y + d.y1,
          width: d.x1 - d.x0,
          height: d.y1 - d.y0,
          data: d.data,
          color: y2(d.value)
          // props.color
        };
      });
      return res;
    }
    function buildTree(data3) {
      const { x: x2 } = getScales();
      const createTreeMap = treemap().size([canvas.value.width - canvas.value.x, canvas.value.height - canvas.value.y]).padding(props.padding);
      const treeFn = stratify().id((d) => d.name).parentId((d) => d.parent);
      const tree = treeFn([{ name: "root" }].concat(data3.map((x3) => {
        return {
          name: x3[props.dataKeys[0]],
          value: x3[props.dataKeys[1]],
          parent: "root"
        };
      })));
      tree.sum((d) => x2(d.value));
      createTreeMap(tree);
      return tree;
    }
    const toKebabCase = (data3) => mapKeys(kebabize, data3);
    const getStyle = (r) => {
      const style = {
        stroke: r.color,
        strokeWidth: 5,
        fill: r.color,
        fillOpacity: 0.9
      };
      if (props.rcStyle && typeof props.rcStyle === "function") {
        return Object.assign(Object.assign({}, style), props.rcStyle(r));
      }
      return style;
    };
    function onMouseOver(i) {
      selected.value = i;
    }
    function onMouseOut() {
      selected.value = null;
    }
    watch(props, () => {
      data2.value = props.data;
      canvas.value = {
        x: props.margin.left,
        y: props.margin.top,
        width: props.size.width - props.margin.right,
        height: props.size.height - props.margin.bottom
      };
      rectangles.value = buildRectangles();
    }, { immediate: true });
    return { el, rectangles, selected, getStyle, toKebabCase, onMouseOver, onMouseOut };
  }
});
var _hoisted_1$1 = {
  class: "treemap",
  style: { display: "flex", position: "relative" }
};
var _hoisted_2$1 = ["width", "height", "viewBox"];
var _hoisted_3 = { class: "layer-rectangles" };
var _hoisted_4 = ["transform", "onMouseover"];
var _hoisted_5 = ["width", "height"];
var _hoisted_6 = {
  x: 0 + 10,
  y: 0 + 20,
  "font-size": `15px`,
  fill: `white`,
  "font-weight": "bold"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    (openBlock(), createElementBlock("svg", {
      width: _ctx.size.width,
      height: _ctx.size.height,
      viewBox: `0 0 ${_ctx.size.width} ${_ctx.size.height}`,
      ref: "el"
    }, [
      createBaseVNode("g", _hoisted_3, [
        (openBlock(true), createElementBlock(
          Fragment,
          null,
          renderList(_ctx.rectangles, (r, i) => {
            return openBlock(), createElementBlock("g", {
              class: normalizeClass(["rectangle", { selected: _ctx.selected === i }]),
              key: i,
              transform: `translate(${r.x0}, ${r.y0})`,
              onMouseover: () => _ctx.onMouseOver(i),
              onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.onMouseOut && _ctx.onMouseOut(...args))
            }, [
              renderSlot(_ctx.$slots, "default", {
                r,
                selected: _ctx.selected === i
              }, () => [
                createBaseVNode("rect", mergeProps(_ctx.toKebabCase(_ctx.getStyle(r)), {
                  x: 0,
                  y: 0,
                  width: r.width,
                  height: r.height
                }), null, 16, _hoisted_5),
                renderSlot(_ctx.$slots, "text", {
                  r,
                  selected: _ctx.selected === i
                }, () => [
                  createBaseVNode(
                    "text",
                    _hoisted_6,
                    toDisplayString(r.data.name),
                    1
                    /* TEXT */
                  )
                ])
              ])
            ], 42, _hoisted_4);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])
    ], 8, _hoisted_2$1)),
    renderSlot(_ctx.$slots, "widgets")
  ]);
}
script$1.render = render$1;
script$1.__file = "src/components/Treemap/index.vue";
var script = defineComponent({
  name: "HoverBar",
  props: {
    barStyle: {
      type: Object,
      default: () => ({ "fill-opacity": 0.05 })
    }
  },
  setup() {
    const chart = useChart();
    const mouse = useMouse();
    const bar = ref({ x: 0, y: 0, width: 0, height: 0 });
    const direction = ref("horizontal");
    const canvas = ref({ x: 0, y: 0, width: 0, height: 0 });
    watch(chart.updates, () => {
      canvas.value = chart.canvas;
      direction.value = chart.config.direction;
    }, { immediate: true });
    watch(mouse, () => {
      if (chart.bandScale) {
        const vals = chart.getData(chart.getKeys(0));
        const [x2] = chart.bandScale.map([vals[mouse.index]]);
        const width = chart.bandScale.bandwidth();
        if (x2) {
          if (chart.config.direction === "horizontal") {
            bar.value = {
              x: x2 - width / 2,
              y: 0,
              width,
              height: canvas.value.height
            };
          } else {
            bar.value = {
              x: 40,
              y: x2 - width / 2,
              width: canvas.value.width - 40,
              height: width
            };
          }
        }
      }
    });
    return { bar, canvas, direction, mouse };
  }
});
var _hoisted_1 = {
  key: 0,
  class: "layer-hover-bar"
};
var _hoisted_2 = ["x", "y", "width", "height"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.mouse.hover ? (openBlock(), createElementBlock("g", _hoisted_1, [
    createBaseVNode("rect", mergeProps({ class: "hover-bar" }, _ctx.barStyle, {
      x: _ctx.bar.x,
      y: _ctx.bar.y,
      width: _ctx.bar.width > 0 ? _ctx.bar.width : 0,
      height: _ctx.bar.height > 0 ? _ctx.bar.height : 0
    }), null, 16, _hoisted_2)
  ])) : createCommentVNode("v-if", true);
}
script.render = render;
script.__file = "src/components/HoverBar/index.vue";
var components = Object.freeze({
  __proto__: null,
  Chart: script$c,
  Layer: script$b,
  Area: script$a,
  Line: script$9,
  Bar: script$8,
  Pie: script$7,
  Responsive: script$6,
  Grid: script$5,
  Tooltip: script$4,
  Group: script$3,
  Marker: script$2,
  Treemap: script$1,
  HoverBar: script
});
var install = function installLib(app) {
  Object.entries(components).forEach(([componentName, component]) => {
    app.component(componentName, component);
  });
};
var index = { install };
export {
  script$a as Area,
  script$8 as Bar,
  script$c as Chart,
  script$5 as Grid,
  script$3 as Group,
  script as HoverBar,
  script$b as Layer,
  script$9 as Line,
  script$2 as Marker,
  script$7 as Pie,
  script$6 as Responsive,
  script$4 as Tooltip,
  script$1 as Treemap,
  index as default,
  useBars,
  useChart,
  useMouse,
  usePoints,
  useResize,
  useTooltip
};
//# sourceMappingURL=vue3-charts.js.map
